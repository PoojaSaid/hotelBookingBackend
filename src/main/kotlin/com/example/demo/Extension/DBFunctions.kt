package com.example.demo.Extension


import org.json.JSONArray
import org.json.JSONObject
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.multipart.MultipartFile
import java.io.File
import java.math.BigDecimal
import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.StandardCopyOption
import java.sql.*
import java.text.SimpleDateFormat
import java.util.*
import java.util.Date
import kotlin.collections.ArrayList


class DBFunctions() {

    companion object {
        var TablePackage = "com.example.demo.Tables"

        val SUCCESS = "SUCCESS"
        val FAILURE = "FAILURE"
        val RESPONSE = "RESPONSE"
        val EXCEPTION = "EXCEPTION"
        val MESSAGE = "MESSAGE"
        const val DATA = "DATA"
        const val STATUS = "STATUS"
        const val SUCCESSFUL = "SUCCESS"
        const val FAILED = "FAILED"
        const val FIELD = "FIELD"
        const val KEY = "KEY"


    }


}

fun jsonInsert(jsonArray: JSONArray, tableName: String, conn: Connection): ArrayList<SQLModel> {
    var sqlList = ArrayList<SQLModel>()
    var pkKeys = ArrayList<Any>()
    var alColType = buildDataType(tableName, conn)

    for (i in 0 until jsonArray.length()) {
        var lsSql = "INSERT INTO $tableName (";
        var jsonObject = jsonArray.get(i) as JSONObject
        var autoColumnName = "";

        //Check from the class that the Primary key must me generated from Class or is it autoGenerated ?
        var generatePK = getFunctionFromFile(DBFunctions.TablePackage + "." + "$tableName", "shouldGeneratePK")

        //if PK needs to be generated by Spring System (not by Database)
        //then below logic gets executed
        if (generatePK[0].toString().equals("true")) {
            pkKeys = getFunctionFromFile(DBFunctions.TablePackage + "." + "$tableName", "getPKKeys")

            //Check Whether primary key exists
            var lbGeneratePK = false;
            for (x in 0 until pkKeys.size) {
                if (jsonObject.has(pkKeys[x].toString()) &&
                        ((jsonObject.isNull(pkKeys[x].toString())) || jsonObject.get(pkKeys[x].toString()) == "null")) {
                    lbGeneratePK = true
                    break
                } else if (!(jsonObject.has(pkKeys[x].toString()))) //if the key is not present in the jsonObject
                {
                    lbGeneratePK = true
                    break
                }
            }

            //Values are not present
            //so generate the primary key from the class
            //please see there is additional argument to getFunctionFromFile
            //because we need to pass JSONObject and the generatePK method
            //will generate PK and set it in the json object which is returned
            //and then used in Insert Statement
            /* if (lbGeneratePK) {
                 var response = getFunctionFromFile(DBFunctions.TablePackage + "." + "$tableName", "generatePK", jsonObject)
                 jsonObject = response[0] as JSONObject
             }*/
            var response = getFunctionFromFile(DBFunctions.TablePackage + "." + "$tableName", "getAutoGeneratedColumnName")
            autoColumnName = response[0].toString()
        } //if pk needs to be generated by Spring System (not by Database)
        else {
            var response = getFunctionFromFile(DBFunctions.TablePackage + "." + "$tableName", "getAutoGeneratedColumnName")
            autoColumnName = response[0].toString()
        }

        for (x in 0 until jsonObject.names().length()) {
            lsSql = lsSql + jsonObject.names().get(x)
            if (x != jsonObject.names().length() - 1) {
                lsSql = lsSql + " , ";
            } else {
                lsSql = lsSql + " ) VALUES (";
            }

        }

        for (x in 0 until jsonObject.length()) {

            var dataValue: String??
            var lsColValue = jsonObject.get(jsonObject.names().get(x) as String)
            lsColValue = lsColValue.toString().replace("'", "\\'");
            dataValue = "'" + lsColValue + "'"
            var colType = filterList(alColType, jsonObject.names().get(x) as String, tableName) as Int

            // if the column types are in numeric category
            // and the value is "''" then put 0 as value
            // Please Note, in case it is mandatory then
            // special care is needed which is still not implemented.

            //not able to use the ENUM Comparision hence hardcoded
            // 2 - Numeric, 3- Decimal, 4- Integer,8-Double
            if (colType == 2 || colType == 3 || colType == 4 || colType == 8) {
                if (dataValue.equals("''")) dataValue = "0"
            }
            if (dataValue != null && dataValue.equals("'null'")) {
                dataValue = null;
            }
            lsSql = lsSql + dataValue
            if (x != jsonObject.names().length() - 1) {
                lsSql = lsSql + " , ";
            } else {
                lsSql = lsSql + " )";
            }


        }

        jsonObject.put("TABLE", tableName);
        var sqlModel = SQLModel(lsSql, jsonObject, pkKeys, tableName, autoColumnName)
        sqlList.add(sqlModel);
        //println("SQL IS " + lsSql)
    }
    return sqlList;
}

fun getFunctionFromFile(fileName: String, funcName: String): ArrayList<Any> {
    val cls = Class.forName(fileName)
    val kotlinClass = cls.kotlin
    val keys = (cls.getMethod(funcName).invoke(kotlinClass.java.newInstance()) as ArrayList<Any>)
    return keys
}

fun buildDataType(tableName: String, conn: Connection): ArrayList<DBModel> {
    var list = ArrayList<DBModel>()
    var st = conn.createStatement()
    var rs = st.executeQuery("SELECT * FROM $tableName WHERE 1 = 2")
    var metaData = rs.metaData
    for (i in 1..metaData.columnCount) {
        var colName = metaData.getColumnName(i)
        var colType = metaData.getColumnType(i)
        var model = DBModel(colName, colType);
        list.add(model)
    }
    return list
}

fun rowsToJsonArray(lsSql: String, conn: Connection?): JSONArray {
    var stmt = conn!!.createStatement()
    var rs = stmt.executeQuery(lsSql)
    var metaData = rs.metaData
    var jsonArray = JSONArray()
    while (rs!!.next()) {
        var jsonObject = JSONObject()
        for (i in 1..metaData.columnCount) {
            var colType = metaData.getColumnType(i)
            if (colType == JDBCType.INTEGER.vendorTypeNumber) {
                jsonObject.put(metaData.getColumnLabel(i), rs.getNullableInt(metaData.getColumnLabel(i)))
            } else if (colType == JDBCType.DOUBLE.vendorTypeNumber) {
                jsonObject.put(metaData.getColumnLabel(i), rs.getNullableDouble(metaData.getColumnLabel(i)))
            } else {
                if (rs.getNullableString(metaData.getColumnLabel(i)) == null) {
                    jsonObject.put(metaData.getColumnLabel(i), JSONObject.NULL)
                } else {
                    jsonObject.put(metaData.getColumnLabel(i), rs.getNullableString(metaData.getColumnLabel(i)))
                }
            }
        }
        jsonArray.put(jsonObject)
    }

    return jsonArray
}

fun rowsToJsonObject(IsSql: String, conn: Connection?): JSONObject {
    var stmt = conn!!.createStatement()
    var rs = stmt.executeQuery(IsSql)
    var metaData = rs.metaData

    var jsonObject = JSONObject()

    while (rs!!.next()) {

        for (i in 1..metaData.columnCount) {
            var colType = metaData.getColumnType(i)
            if (colType == JDBCType.INTEGER.vendorTypeNumber) {

                jsonObject.put(metaData.getColumnLabel(i), rs.getNullableInt(metaData.getColumnLabel(i)))
            } else if (colType == JDBCType.DOUBLE.vendorTypeNumber) {

                jsonObject.put(metaData.getColumnLabel(i), rs.getNullableDouble(metaData.getColumnLabel(i)))
            } else {
                if (rs.getNullableString(metaData.getColumnLabel(i)) == null) {
                    jsonObject.put(metaData.getColumnLabel(i), JSONObject.NULL)
                } else {
                    jsonObject.put(metaData.getColumnLabel(i), rs.getNullableString(metaData.getColumnLabel(i)))
                }
            }
        }
    }
    return jsonObject
}

fun maxRangeID(tableName: String, columnName: String, conn: Connection?): String {
    val IsSQL = "SELECT count($columnName) as dataCount from ${tableName} "

    val stmt = conn!!.createStatement()
    val rs = stmt.executeQuery(IsSQL)

    var servID = 0

    while (rs!!.next()) {
        servID = rs.getInt("dataCount")!!
    }
    servID = servID + 1
    return servID.toString()
}

fun getDBConnection(): Connection? {
    val connectProps = Properties()


    //DevServer New
//    connectProps.put("user", "root")
//    connectProps.put("password", "Appvantis@2019")

    //Local
    connectProps.put("password", "root")
    connectProps.put("user", "root")

    var conn: Connection? = null

    try {
        Class.forName("com.mysql.jdbc.Driver").newInstance()


//        Local 1.2
//        conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/dwellze_db_1_2?autoReconnect=true&useUnicode=true&characterEncoding=UTF-8&allowMultiQueries=true&useSSL=false", connectProps)

        // Dev 1.2
        conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/hotelbooking?autoReconnect=true&useUnicode=true&characterEncoding=UTF-8&allowMultiQueries=true&useSSL=false&serverTimezone=UTC", connectProps)

        //   conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/SocAdmin_SIT?autoReconnect=true&useUnicode=true&characterEncoding=UTF-8&allowMultiQueries=true&useSSL=false",connectProps)
        // conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/dwellze_db?autoReconnect=true&useUnicode=true&characterEncoding=UTF-8&allowMultiQueries=true&useSSL=false",connectProps)
        // conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/SocAdmin?autoReconnect=true&useUnicode=true&characterEncoding=UTF-8&allowMultiQueries=true&useSSL=false", connectProps)

    } catch (ex: SQLException) {
        ex.printStackTrace();
    } catch (ex: Exception) {
        ex.printStackTrace()
    }
    return conn
}

fun ResultSet.getNullableString(colName: String): String? {
    val value = this.getString(colName)
    return if (this.wasNull()) null else value
}

fun ResultSet.getNullableDouble(colName: String): Double? {
    val value = this.getDouble(colName)
    return if (this.wasNull()) null else value
}

fun ResultSet.getNullableInt(colName: String): Int? {
    val value = this.getInt(colName)
    return if (this.wasNull()) null else value
}


class SQLModel {
    public var statement = ""
    public var jsonObject = JSONObject()
    public var responseKEY = ArrayList<Any>()
    public var tableName = ""
    public var autoGeneratedColumn = ""


    constructor(sqlStatement: String, json: JSONObject, pkKeys: ArrayList<Any>, tableName: String, autoColumn: String) {
        statement = sqlStatement
        jsonObject = json
        responseKEY = pkKeys
        this.tableName = tableName
        autoGeneratedColumn = autoColumn
    }

}


class DBModel {
    var colName = "";
    var colType = 0;

    constructor(colName: String, colType: Int) {
        this.colName = colName
        this.colType = colType
    }
}

fun filterList(listCustom: List<DBModel>?, colName: String, tableName: String): Int {

    if (listCustom!!.filter { it.colName == colName }.size > 0) {
        var filterList = listCustom!!.filter { it.colName == colName }
        return filterList[0].colType
    } else {
        throw Exception("Column $colName not Found in $tableName");
    }
}







